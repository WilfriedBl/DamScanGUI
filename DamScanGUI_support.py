"""GUI-front-end for DamScan & DamCompare version 1.4.0 by Juha Lintula"""
#
#   Copyright Wilfried Blankertz, 2017
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
__version__ = "0.1.5"
#
# Support module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6
#    Oct 13, 2017 10:00:37 PM

# version history:
# 0.1.0 First "stable" version
# 0.1.1 Several issues of 26.09.2017
# 0.1.3 New tags for DamScan 1.4.0 / Netcatalogs selectable from list box
# 0.1.3a Avoid crash, when server name or port are wrong
# 0.1.4 Selection from list boxes with double click, second Netcatalog selectable from list box, cleaner panel layout
# 0.1.5 Buttons, checkboxes and lists don't get focus when using the tab key.
# ToDo: Error messages for validity check on each field in the GUI

import argparse
import configparser
import os
import shlex
import socket
import subprocess
from datetime import datetime
# from inspect import currentframe, getframeinfo
from tkinter import *
from tkinter import filedialog

import psycopg2


def set_Tk_var():
    global txt_dbpath;  txt_dbpath = StringVar()
    global txt_dbname;  txt_dbname = StringVar()
    global txt_user;    txt_user = StringVar()
    global txt_password; txt_password = StringVar()
    global txt_server;  txt_server = StringVar()
    global txt_port;    txt_port = StringVar()
    global ckb_sqlite;  ckb_sqlite = IntVar()
    global txt_catalog_dates;   txt_catalog_dates = StringVar()
    global txt_catalog2_dates;  txt_catalog2_dates = StringVar()
    global lst_netcatalogs; lst_netcatalogs = StringVar()
    global rbtn_verbose; rbtn_verbose = StringVar()
    global ckb_display_only; ckb_display_only = IntVar()
    global ckb_itemid;      ckb_itemid = StringVar()
    global ckb_fullpath;    ckb_fullpath = StringVar()
    global txt_outfilename; txt_outfilename = StringVar()
    global lstb_recent_ini_files; lstb_recent_ini_files = StringVar()
    global txt_newdamscanini; txt_newdamscanini = StringVar()
    global txt_damscanini;  txt_damscanini = StringVar()
    global txt_basename;    txt_basename = StringVar()
    global txt_exfile;      txt_exfile = StringVar()
    global txt_onlyfile;    txt_onlyfile = StringVar()
    global txt_ack_pairs;   txt_ack_pairs = StringVar()
    global txt_pathconfigfiles; txt_pathconfigfiles = StringVar()
    global txt_damscanpgm;  txt_damscanpgm = StringVar()
    global ckb_group;       ckb_group = StringVar()
    global txt_dbpath2;     txt_dbpath2 = StringVar()
    global txt_dbname2;     txt_dbname2 = StringVar()
    global txt_damcompgm;   txt_damcompgm = StringVar()
    global txt_excludepaths; txt_excludepaths = StringVar()
    global txt_onlypaths;   txt_onlypaths = StringVar()
    global ckb_event;       ckb_event = IntVar()
    global ckb_gps;         ckb_gps = IntVar()
    global ckb_collections; ckb_collections = IntVar()
    global ckb_people;      ckb_people =IntVar()
    global ckb_keywords;    ckb_keywords = IntVar()
    global ckb_categories;  ckb_categories =IntVar()
    global ckb_place;       ckb_place =IntVar()
    global ckb_title;       ckb_title =IntVar()
    global ckb_description; ckb_description =IntVar()
    global ckb_comments;    ckb_comments =IntVar()
    global ckb_verify_basenames; ckb_verify_basenames = IntVar()
    global rbtn_verbose_gui; rbtn_verbose_gui = StringVar()
    global rbtn_analysis_type; rbtn_analysis_type = StringVar()
    global msg_error;       msg_error = StringVar()

    global analysis_type
    analysis_type = StringVar()
    global verbose_gui
    global args  # , analysis_type
    global alltags
    global damprocess  # Subprocess to run DamScan or DamCompare in
    global RecentDamScanINIfiles

    alltags = ["Event", "Place", "GPS", "Title", "Description", "Comments",
               "People", "Keywords", "Categories", "Collections"]

    # ToDo: Verbose for GUI

    args = read_config_for_gui(None)  # Read command line arguments & configuration file, if it exist otherwise create a new one

    if int(args.verbose) > 1:
        print('Func. set_Tk_var() line:', getframeinfo(currentframe()).lineno, "Var. analysis_type:",
              analysis_type)  # for debugging

    populate_GUI_panel()
    if int(rbtn_verbose_gui.get()) > 1:
       print('Func. set_Tk_var() line:', getframeinfo(currentframe()).lineno,
             "Var. analysis_type:", analysis_type)                              # for debugging
    return analysis_type


def read_ini(args, conf):
    global alltags, analysis_type

    if args.ini_file is not None and conf.read(args.ini_file.replace('"', '').replace(".ini", "") + ".ini",
                                               encoding='utf-8') == []:
        sys.stderr.write("INI File " + args.ini_file + " doesn't exist. Option ignored.\n")

    if args.sqlite is None:                         args.sqlite = conf.getboolean('Database', 'SQLite', fallback=False)
    if args.dbname is None:
        if conf.has_option('Database', 'Catalog'):
            args.dbname = conf['Database']['Catalog']
        elif args.sqlite:
            args.dbname = "DaminionCatalog.dmc"
        else:
            args.dbname = "NetCatalog"
    if args.dbname1 is None:                        args.dbname1 = conf.get('Database', 'Catalog1', fallback=None)
    if args.dbname2 is None:                        args.dbname2 = conf.get('Database', 'Catalog2', fallback=None)
    if args.port is None:                           args.port = conf.getint('Database', 'Port', fallback=5432)
    if args.server is None:                         args.server = conf.get('Database', 'Server', fallback='localhost')
    if args.user is None:                           args.user = conf.get('Database', 'User',
                                                                         fallback="postgres/postgres")
    if args.fullpath is None:                       args.fullpath = conf.getboolean('Session', 'Fullpath',
                                                                                    fallback=False)
    if args.id is None:                             args.id = conf.getboolean('Session', 'ID', fallback=False)
    if args.group is None:                          args.group = conf.getboolean('Session', 'Group', fallback=False)
    if args.basename is None:
        base = conf.get('Session', 'Basename', fallback=None)
        if base is not None:                        args.basename = base.split()
    if args.taglist is None:
        taglist = conf.get('Session', 'Tags', fallback=None)
        if taglist is None or taglist.lower() == "all":
            args.taglist = alltags
        else:
            args.taglist = taglist.split()

    if args.ack_pairs is None:                      args.ack_pairs = conf.get('Session', 'acknowledged', fallback=None)

    if args.exfile is None and args.onlyfile is None:
        excf = conf.get('Session', 'exclude', fallback=None)
        incf = conf.get('Session', 'only', fallback=None)
        if excf is not None and incf is not None:
            sys.stderr.write("* Warning: INI file has specified both exclude={} and only={} â€“ {} ignored\n".format(
                excf, incf, incf))
            incf = None
        args.exfile = excf
        args.onlyfile = incf

    dirlist = conf.get('Session', 'OnlyPaths', fallback="")
    if dirlist is not None:
        args.onlydir = shlex.split(dirlist, posix=False)  # DamCompare
        # if int(rbtn_verbose_gui.get()) > 1:
        #     print('Function read_ini(args, conf):', getframeinfo(currentframe()).lineno,  # for debugging
        #          "\ndirlist:", dirlist, "\nargs.onlydir:", args.onlydir, dirlist)
    if args.exdir is None:
        dirlist = conf.get('Session', 'ExcludePaths', fallback="")
        if dirlist is not None:                             args.exdir = shlex.split(dirlist)  # DamCompare

    if args.outfilename is None:
        file = conf.get('Session', 'Outfile', fallback=None)
    else:
        file = args.outfilename
    if file is None or file in ("", "<stdout>"):
        args.outfile = sys.stdout
    else:
        args.outfilename = file

    if args.verbose is None:
        args.verbose = conf.getint('Session', 'Verbose', fallback=0)

    analysis_type = conf.get('Session', 'AnalysisType', fallback=analysis_type)


def create_parser():
    global alltags

    parser = argparse.ArgumentParser(
        description="Search inconcistent tags from a Daminion database.")

    # key identification arguments
    parser.add_argument("--ini", dest="ini_file", help="INI file for scan parameters.")
    parser.add_argument("-g", "--group", dest="group", action="store_const", const=True, default=None,
                        help="Use groups/stacks instead of image links")  # default=False,
    parser.add_argument("-f", "--fullpath", dest="fullpath", action="store_const", const=True, default=None,
                        help="Print full directory path and not just file name")  # default=False,
    parser.add_argument("-i", "--id", dest="id", action="store_const", const=True, default=None,
                        help="Print database id after the filename")  # default=False,
    parser.add_argument("-t", "--tags", dest="taglist", nargs='*', choices=alltags,  # default=alltags,
                        help="Tag categories to be checked [all]."
                             "Allowed values for taglist are Event, Place, GPS, Title, Description, Comments, People, "
                             "Keywords, Categories and Collections.")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("-x", "--exclude", dest="exfile",
                       help="Configuration file for tag values that are excluded from comparison.")
    group.add_argument("-y", "--only", dest="onlyfile",
                       help="Configuration file for tag values that are only used for comparison.")

    groupc = parser.add_mutually_exclusive_group()
    groupc.add_argument("-xc", "--excludepaths", dest="exdir", nargs='+',
                        help="List of folder paths that are excluded from comparison.")
    groupc.add_argument("-yc", "--onlypaths", dest="onlydir", nargs='+',
                        help="List of folder paths that are included for comparison.")

    parser.add_argument("-a", "--acknowledged", dest="ack_pairs",
                        help="File containing list of acknowledged differences.")
    parser.add_argument("-v", "--verbose", action="count", dest="verbose", default=1,
                        help="verbose output (always into stdout)")  # default for GUI=1,
    parser.add_argument("-b", "--basename", dest="basename", nargs='*', metavar="SEPARATOR",
                        help="Compare the basename of the files. If additional strings are specified, those are also used as separators, unless the filename is <= 8 chars.")
    #    group = parser.add_mutually_exclusive_group()
    parser.add_argument("-l", "--sqlite", dest="sqlite", action="store_const", const=True, default=None,
                        help="Use Sqlite (= standalone) instead of Postgresql (=server)")  # default=False,
    parser.add_argument("-c", "--catalog", dest="dbname",
                        help="Daminion catalog name [NetCatalog]")  # default="NetCatalog",
    parser.add_argument("-c1", "--catalog1", dest="dbname1",
                        help="Daminion catalog name [NetCatalog]")  # nargs=1,  # default="NetCatalog",
    parser.add_argument("-c2", "--catalog2", dest="dbname2",
                        help="Daminion catalog name [NetCatalog]")  # nargs=1,  # default="NetCatalog",
    parser.add_argument("-s", "--server", dest="server", help="Postgres server [localhost]")
    parser.add_argument("-p", "--port", dest="port", type=int, help="Postgres server port [5432]")  # default=5432,
    parser.add_argument("-u", "--user", dest="user",
                        help="Postgres user/password [postgres/postgres]")  # default="postgres/postgres",
    parser.add_argument("-o", "--output", dest="outfilename",
                        help="Output file for report [stdout]")  # type=argparse.FileType('w', encoding='utf-8'), # default=sys.stdout,
    parser.add_argument("--version", action="store_true", dest="version", default=False,
                        help="Display version information and exit.")

    conf = configparser.ConfigParser(allow_no_value=True)
    conf.BOOLEAN_STATES['include'] = True
    conf.BOOLEAN_STATES['exclude'] = False
    #    conf.delimeters = ('=', )

    return parser, conf


def populate_GUI_panel():  # Set Values to display at the GUI
    global args, analysis_type, rows
    #    rbtn_analysis_type.set("Scan")
    rbtn_verbose_gui.set("1")
    if int(rbtn_verbose_gui.get()) > 0:
        print(sys.argv[0], 'Version', __version__, '\n' + __doc__,
              '\nstarted at {:%H:%M:%S}'.format(datetime.now()))
    if int(rbtn_verbose_gui.get()) > 1:
        print('Func populate_GUI_panel():', getframeinfo(currentframe()).lineno, "Variable:")  # Debug

    txt_damscanpgm.set(damscanpgm)  # .replace(".py"," "))           # Name & Path for DamScan.py
    txt_damcompgm.set(damcompgm)  # .replace(".py", " "))            # Name & Path for DamCompare.py
    rbtn_analysis_type.set(analysis_type)  # DamScan 6 DamCompare
    txt_damscanini.set(args.ini_file.replace(".ini", ""))  # Current INI file for DamScan or DamCompare

    txt_dbname.set(str((args.dbname.split('\\'))[-1]).rstrip('"'))
    txt_dbpath.set(str(args.dbname.rstrip(args.dbname.split('\\')[-1])).strip('"'))
    if args.dbname2 is not None:
        txt_dbname2.set(str((args.dbname2.split('\\'))[-1]).rstrip('"'))  # .replace(".dmc",""))
        txt_dbpath2.set(str(args.dbname2.rstrip(args.dbname2.split('\\')[-1])).strip('"'))

    txt_server.set(args.server)  # -s SERVER, --server SERVER Postgres server [localhost]
    txt_port.set(args.port)  # -p PORT, --port PORT  Postgres server port [5432]
    user = args.user.split('/')[0]  # -u USER --user USER  Postgres user/password [postgres/postgres]
    txt_user.set(user)
    password = args.user.split('/')[1]
    txt_password.set(password)
    if args.sqlite:
        ckb_sqlite.set(True)                # -l, --sqlite Use Sqlite (= standalone)
        if os.path.exists(args.dbname):
            filecreatedate = datetime.fromtimestamp(os.path.getctime(args.dbname)).strftime(
                '\ncreated on %d.%m.%Y %H:%M:%S')
            filechangedate = datetime.fromtimestamp(os.path.getmtime(args.dbname)).strftime(
                'last changed on %d.%m.%Y %H:%M:%S')
            if int(rbtn_verbose_gui.get()) > 0:
                print("Daminion catalog found: " + args.dbname, filecreatedate + ",", filechangedate)
            txt_catalog_dates.set(filecreatedate + ", " + filechangedate)
        else:
            txt_catalog_dates.set("Daminion catalog "+args.dbname+" not found!")
            if int(rbtn_verbose_gui.get()) > 0: print(txt_catalog_dates.get())
        if os.path.exists(args.dbname2):
            filecreatedate = datetime.fromtimestamp(os.path.getctime(args.dbname2)).strftime(
                '\ncreated on %d.%m.%Y %H:%M:%S')
            filechangedate = datetime.fromtimestamp(os.path.getmtime(args.dbname2)).strftime(
                'last changed on %d.%m.%Y %H:%M:%S')
            if int(rbtn_verbose_gui.get()) > 0:
                print("Second Daminion catalog found: " + args.dbname2, filecreatedate + ",", filechangedate)
            txt_catalog2_dates.set(filecreatedate + ", " + filechangedate)
        else:
            if int(rbtn_verbose_gui.get()) > 0: print("Second Daminion catalog", args.dbname, "not found!")
            txt_catalog2_dates.set("Second Daminion catalog not found!")

    else:                                    # not -l => Postgresql (=server)
        ckb_sqlite.set(False)
        toggle_sqlite()

    rbtn_verbose.set(args.verbose)      # -v, --verbose         verbose output (always into stdout)

    # --version             Display version information and exit.)
    #    ckb_version.set(args.version) ---> Only selectable by button
    ckb_group.set(args.group)           # -g, --group           Use groups/stacks instead of image links\n
    ckb_fullpath.set(args.fullpath)     # -f, --fullpath        Print full directory path and not just file name\n
    ckb_itemid.set(args.id)             # -i, --id              Print database id after the filename\n

    # Define one checkbox for each tag in list alltags

    if 'GPS' in args.taglist: ckb_gps.set(True)
    if 'Event' in args.taglist: ckb_event.set(True)
    if 'Place' in args.taglist: ckb_place.set(True)
    if 'Title' in args.taglist: ckb_title.set(True)
    if 'People' in args.taglist: ckb_people.set(True)
    if 'Comments' in args.taglist: ckb_comments.set(True)
    if 'Keywords' in args.taglist: ckb_keywords.set(True)
    if 'Categories' in args.taglist: ckb_categories.set(True)
    if 'Collections' in args.taglist: ckb_collections.set(True)
    if 'Description' in args.taglist: ckb_description.set(True)

    #  -b [SEPARATOR [SEPARATOR ...]], --basename [SEPARATOR [SEPARATOR ...]] Compare the basename of the files.
    # If additional strings are specified, those are also used as separators, unless the filename is <= 8 chars.
    if args.basename is not None:
        txt_basename.set(args.basename)
        ckb_verify_basenames.set(True)
    else:
        ckb_verify_basenames.set(False)

    # -x EXFILE, --exclude EXFILE\n Configuration file for tag values that are excluded from comparison.
    if args.exfile is not None:
        txt_exfile.set(args.exfile)
        # txt_pathconfigfiles.set(args.exfile.rstrip(args.exfile.split('\\')[-1]))

    if args.onlyfile is not None:  # -y ONLYFILE, --only ONLYFILE; Configuration file for tag values that are only used for scan
        txt_onlyfile.set(args.onlyfile)
        # txt_pathconfigfiles.set(args.onlyfile.rstrip(args.onlyfile.split('\\')[-1]))

    if args.exdir is not None:
        if args.exdir != []:
            txt_excludepaths.set(('"' + '" "'.join(map(str, args.exdir)) + '"').replace('""','"'))
            if int(rbtn_verbose_gui.get()) > 1:
                print('Function populate_GUI_panel():', getframeinfo(currentframe()).lineno,   # for debugging
                  " args:\n", args.exdir, "\ntxt_excludepaths.get", txt_excludepaths.get())

    if args.onlydir is not None:
        if args.onlydir != []:
            txt_onlypaths.set(('"' + '" "'.join(map(str, args.onlydir)) + '"').replace('""','"'))
            if int(rbtn_verbose_gui.get()) > 1:
                print('Function populate_GUI_panel():', getframeinfo(currentframe()).lineno,   # for debugging
                  " args:\n", args.onlydir, "\ntxt_onlypaths.get", txt_onlypaths.get())

    if args.ack_pairs is not None:  # -a ACK_PAIRS, --acknowledged ACK_PAIRS File containing list of acknowledged differences.
        txt_ack_pairs.set(args.ack_pairs)
        # txt_pathconfigfiles.set(args.ack_pairs.rstrip(args.ack_pairs.split('\\')[-1]))

    # print('Func populate_GUI_panel():', getframeinfo(currentframe()).lineno,
    #             "Variable args.outfilename:", args.outfilename)                              # for debugging
    if args.outfilename is not None:  # -o OUTFILE, --output OUTFILE Output file for report [stdout]
        if args.outfilename not in ("<stdout>", "", " "):
            txt_outfilename.set(args.outfilename.replace('/', '\\'))
            ckb_display_only.set(FALSE)
        else:
            ckb_display_only.set(TRUE)
    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. populate_GUI_panel() line:', getframeinfo(currentframe()).lineno, "Var. analysis_type:",
              analysis_type)  # for debugging


def WriteIni(damscaninifile):
    global args, analysis_type
    # INI-file for DamScan.py
    conf = configparser.ConfigParser(allow_no_value=True)
    conf.optionxform = str
    conf['Database'] = {}
    if args.sqlite:             conf['Database']['SQLite'] = "True"
    if args.dbname is not None:
        conf['Database']['Catalog'] = str(args.dbname)
    elif args.sqlite:
        conf['Database']['Catalog'] = "DaminionCatalog.dmc"
    else:
        conf['Database']['Catalog'] = "NetCatalog"
    if args.server is not None and not args.sqlite:
        conf['Database']['Server'] = str(args.server).rstrip(" ")
    if args.port is not None and not args.sqlite:
        conf['Database']['Port'] = str(args.port)
    if args.user is not None and not args.sqlite:
        conf['Database']['User'] = str(args.user)

    conf['Session'] = {}
    if args.fullpath:               conf['Session']['Fullpath'] = "True"
    if args.id:                     conf['Session']['ID'] = "True"
    #    print("ckb_verify_basenames.get() ..:", ckb_verify_basenames.get(),"\nargs.basename", args.basename)
    if args.basename not in (None, "", " "):
        conf['Session']['Basename'] = str(args.basename).strip("(,')")
    elif ckb_verify_basenames.get():
        conf['Session']['Basename'] = ""
    else:
        conf.remove_option('Session', 'Basename')

    if args.group:                  conf['Session']['Group'] = "True"
    if args.taglist is None:
        conf['Session']['Tags'] = "All"
    else:
        conf['Session']['Tags'] = ' '.join(args.taglist)
    if args.exfile != None:
        if args.exfile != "":
            conf['Session']['Exclude'] = str(args.exfile)
    if args.exdir != None:
        if args.exdir != "":
            conf['Session']['ExcludePaths'] = str(args.exdir)
    if args.onlydir != None:
        if args.onlydir != "":
            conf['Session']['OnlyPaths'] = str(args.onlydir)
    if args.onlyfile != None:
        if args.onlyfile != "":
            conf['Session']['Only'] = str(args.onlyfile)
    if args.ack_pairs != None:
        if args.ack_pairs != "":
            conf['Session']['AckPairs'] = str(args.ack_pairs)
    if args.outfilename != None:
        if args.outfilename != "<stdout>":
            conf['Session']['Outfile'] = str(args.outfilename)
    if args.verbose == 1:
        conf['Session']['Verbose'] = '1'
    elif args.verbose == 2:
        conf['Session']['Verbose'] = '2'
    else:
        conf['Session']['Verbose'] = '0'
    # Parameter for DamCompare
    #    print("WriteIni() 375 \n args.dbname1", args.dbname1, "\ndamscaninifile:", damscaninifile)
    if args.dbname1 is not None:  conf.set('Database', 'Catalog', str(args.dbname1))
    if args.dbname2 is not None:  conf.set('Database', 'Catalog2', str(args.dbname2))
    if args.onlydir is not None:
        if args.onlydir != []:
            conf.set('Session', 'OnlyPaths',
                     str(args.onlydir).strip("[]").replace("'", '"').replace(",", "").replace("\\\\", "\\"))
    if args.exdir is not None:
        if args.exdir != []:
            conf.set('Session', 'ExcludePaths',
                     str(args.exdir).strip("[]").replace("'", '"').replace(",", "").replace("\\\\", "\\"))

    conf['Session']['AnalysisType'] = analysis_type

    with open(damscaninifile, "w") as configfile:
        conf.write(configfile)

    print('DamScanGUI - Config file "' + os.path.abspath(configfile.name), end='" written')

    return configfile


def read_config_for_gui(newdamscanini):
    global gui_conf_file_name
    global damscanpgm, damcompgm, analysis_type, RecentDamScanINIfiles
    global args
    damscanpgm = damcompgm = ""
    gui_conf_file_name = 'DAMScanGUI.config'

    parser, conf = create_parser()
    args = parser.parse_args()

    #    print("Func. read_config_for_gui - create_parser args:", args)

    configGUI = configparser.ConfigParser(allow_no_value=True)
    configGUI.optionxform = str

    # Create new config file for GUI, if it does not exist yet
    if not os.path.exists(gui_conf_file_name):
        configGUI.add_section('DamScanGUI_INI')
        configGUI.set('DamScanGUI_INI', 'MostRecentScanPgm', 'DamScan.py')
        configGUI.set('DamScanGUI_INI', 'MostRecentCompPgm', 'DamCompare.py')
        configGUI.set('DamScanGUI_INI', 'MostRecentAnalysisType', 'Scan')
        configGUI.set('DamScanGUI_INI', 'MostRecentArgs', '-o "<stdout>" ')
        configGUI.set('DamScanGUI_INI', 'RecentDamScanINIfiles', 'DamScan.ini')
        with open(gui_conf_file_name, "w") as config_file:
            configGUI.write(config_file)

        # Read config file for GUI
    configGUI.read(gui_conf_file_name)
    analysis_type = configGUI.get('DamScanGUI_INI', 'MostRecentAnalysisType', fallback='Scan')
    # if int(rbtn_verbose_gui.get()) > 0: # ToDo verbose_gui -> .config
    # print('Func. read_config_for_gui():', getframeinfo(currentframe()).lineno, "Var. analysis_type:", analysis_type )  # for debugging
    parser, conf = create_parser()
    recentargs = configGUI['DamScanGUI_INI']['MostRecentArgs']

    #    args = parser.parse_args(shlex.split(configGUI.get('DamScanGUI_INI', 'MostRecentArgs')))
    #    args = parser.parse_args(shlex.split(configGUI['DamScanGUI_INI']['MostRecentArgs']))
    args = parser.parse_args()
    damscanpgm = configGUI['DamScanGUI_INI']['MostRecentScanPgm']
    damcompgm = configGUI['DamScanGUI_INI']['MostRecentCompPgm']

    # Find the names of recently used INI files for DamScan or DamCompare
    RecentDamScanINIfiles = shlex.split(configGUI['DamScanGUI_INI']['RecentDamScanINIfiles'].replace('.ini', ''))
    lstb_recent_ini_files.set(RecentDamScanINIfiles)
    if newdamscanini is not None:
        args.ini_file = newdamscanini  # Other INI selected in GUI
    else:
        args.ini_file = RecentDamScanINIfiles[0]  # otherwise take last recently used

    if args.ini_file is None:
        args.ini_file = "DamScan.ini"  # or Default
        newdamscanini = args.ini_file

    if conf.read(args.ini_file, encoding='utf-8') == []:  # Create default INI file, if none exist
        print("DamScanGUI - Create new ini-file:", args.ini_file)  # & fill with arguments from command line
        WriteIni(args.ini_file)

    # Read the most recently used or newly selected ini file
    parser, conf = create_parser()
    conf.read(args.ini_file, encoding='utf-8')
    read_ini(args, conf)

    try:  # ????
        testforinifile = open(args.ini_file)
    except IOError:
        print("INI file", args.ini_file, "does not exist")
        return

    newdamscanini = os.path.basename(testforinifile.name)
    testforinifile.close()
    args.ini_file = newdamscanini
    txt_newdamscanini.set(newdamscanini.replace(".ini", ""))
    txt_damscanini.set(newdamscanini.replace(".ini", ""))

    return args


def browse_ini_files(event=None):
    if int(rbtn_verbose_gui.get()) > 0: print('Func: browse_ini_files(event=None)')

    #    root = Tk()<- not necessary
    inifile = filedialog.askopenfilename(initialdir=os.getcwd(),  # see https://pythonspot.com/en/tk-file-dialogs/
                                         title="Select Options (.ini file) to Analyze Daminion Catalog(s)",
                                         filetypes=(("Ini files", "*.ini"), ("all files", "*.*")))
    if inifile != "":
        txt_newdamscanini.set(str(inifile))
        load_options_from_ini_file()
    return


def load_options_from_ini_file():
    global gui_conf_file_name
    global args, analysis_type

    if txt_newdamscanini.get() != "":  # Prepare to read another ini file after new name was
        newdamscanini = str(txt_newdamscanini.get())  # entered and button pressed or selected from file dialog
        newdamscanini = newdamscanini.rstrip(" ").replace(".ini", "") + ".ini"
        if int(rbtn_verbose_gui.get()) > 0:
            print('DamScanGUI - Loading Options from', newdamscanini)
        if os.path.exists(newdamscanini):
            read_config_for_gui(newdamscanini)
            populate_GUI_panel()
        else:
            print("File", newdamscanini, "does not exist")

    return


def save_options_to_ini_files(event=None):
    global args
    global gui_conf_file_name
    global damscanpgm, damcompgm
    global analysis_type

    analysis_type = rbtn_analysis_type.get()
    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. save_options_to_ini_files(event=None):', getframeinfo(currentframe()).lineno, "Variable:",
              analysis_type)  # for debugging

    newCmd, newCmdstring = build_CMD_line()
    parser, conf = create_parser()
    args = parser.parse_args()
    #    print("save_options_to_ini_files:", args)
    if txt_server.get() > "0": args.server = txt_server.get()
    if txt_port.get() > "0": args.port = txt_port.get()
    if txt_user.get() > "0": args.user = txt_user.get()
    if txt_password.get() > "0": args.user += "/" + txt_password.get()

    if analysis_type == 'Scan':
        show_cmd_str_scan()
    else:
        show_cmd_str_compare()

    configGUI = configparser.ConfigParser(allow_no_value=True)  # .config file (ConfigParser) for DamScanGUI
    configGUI.optionxform = str
    configGUI.read(gui_conf_file_name)
    RecentDamScanINIfiles = shlex.split(configGUI['DamScanGUI_INI']['RecentDamScanINIfiles'])
    #    print("RecentDamScanINIfiles->", RecentDamScanINIfiles)

    #    configGUI.add_section('DamScanGUI_INI')  <-- not necessary, because we read ini file first
    configGUI.set('DamScanGUI_INI', 'MostRecentArgs', newCmdstring)
    configGUI.set('DamScanGUI_INI', 'MostRecentScanPgm', damscanpgm)
    configGUI.set('DamScanGUI_INI', 'MostRecentCompPgm', damcompgm)
    configGUI.set('DamScanGUI_INI', 'MostRecentAnalysisType', analysis_type)

    if txt_damscanini.get() is None:
        damscanini = "DamScan.ini"  # Default ini for DamScan.py or DamCompare.py
    else:
        damscanini = str(txt_damscanini.get().replace(" ", "_"))  # Replace spaces by underscore (_)
    damscanini = damscanini.rstrip(" ").replace(".ini", "") + ".ini"  # make sure extension is .ini

    if damscanini in RecentDamScanINIfiles:  # To add the newly selected name to the list of
        RecentDamScanINIfiles.remove(damscanini)  # most recently used ini files
    RecentDamScanINIfiles.insert(0, damscanini)  # first remove it, if it already is member of the list
    lstb_recent_ini_files.set(RecentDamScanINIfiles)  # Place it at the top of the list
    #    print("RecentDamScanINIfiles->", RecentDamScanINIfiles)

    configGUI.set('DamScanGUI_INI', 'RecentDamScanINIfiles', ' '.join(RecentDamScanINIfiles))

    with open(gui_conf_file_name, "w") as config_file:
        configGUI.write(config_file)  # Write config file for GUI

    # print('Function save_options_to_ini_files:',
    #       getframeinfo(currentframe()).lineno, "damscanini :", damscanini)  # for debugging

    configfile = WriteIni(damscanini)  # Write selected .ini file for DamScan/DamCompare

    if int(rbtn_verbose_gui.get()) > 1:
        print('Function run_damcompare_no_save line:', getframeinfo(currentframe()).lineno, "variable: damscanini",
              damscanini)
    if int(rbtn_verbose_gui.get()) > 0:
        print(' and options from the panel saved into file:', os.path.abspath(gui_conf_file_name))
    return configfile


def browse_for_acknowledged_list():
    print('DamScanGUI_support.browse_for_acknowledged_list')
    sys.stdout.flush()
    file = filedialog.askopenfilename(  # see https://pythonspot.com/en/tk-file-dialogs/
        initialdir=txt_pathconfigfiles.get(),
        title="Select File with List of Achnowledged Pairs to be Excluded from Comparison",
        filetypes=(("Text files", "*.txt"), ("all files", "*.*")))
    if file != "":
        txt_ack_pairs.set(str(file.strip('"').replace('/', '\\')))


def browse_dmc_1(event=None):  # see https://pythonspot.com/en/tk-file-dialogs/
    dmcfile = filedialog.askopenfilename(initialdir=txt_dbpath.get(), title="Select a Local Daminion Catalog",
                                         filetypes=(("Daminion Catalogs", "*.dmc"), ("all files", "*.*")))
    if dmcfile != "":
        txt_dbname.set(str((dmcfile.split('/'))[-1]).rstrip('"'))
        txt_dbpath.set(str(dmcfile.rstrip(dmcfile.split('/')[-1])).strip('"').replace("/", "\\"))
        filecreatedate = datetime.fromtimestamp(os.path.getctime(dmcfile)).strftime('created on %d.%m.%Y %H:%M:%S')
        filechangedate = datetime.fromtimestamp(os.path.getmtime(dmcfile)).strftime('last changed on %d.%m.%Y %H:%M:%S')
        print("Daminion catalog", filecreatedate + ",\n" + filechangedate, "found:\n" + dmcfile)
        txt_catalog_dates.set(filecreatedate + ", " + filechangedate)
        ckb_sqlite.set(TRUE)  # If we find the file locally, we assume SQLite
    return


def browse_dmc_2(event=None):  # see https://pythonspot.com/en/tk-file-dialogs/
    dmcfile = filedialog.askopenfilename(
        initialdir=txt_dbpath2.get(), title="Select a Second Local Daminion Catalog to Compare with",
        filetypes=(("Daminion Catalogs", "*.dmc"), ("all files", "*.*")))
    if dmcfile != "":
        txt_dbname2.set(str((dmcfile.split('/'))[-1]).rstrip('"'))
        txt_dbpath2.set(str(dmcfile.rstrip(dmcfile.split('/')[-1])).strip('"').replace("/", "\\"))
        filecreatedate = datetime.fromtimestamp(os.path.getctime(dmcfile)).strftime('created on %d.%m.%Y %H:%M:%S')
        filechangedate = datetime.fromtimestamp(os.path.getmtime(dmcfile)).strftime('last changed on %d.%m.%Y %H:%M:%S')
        print("Daminion catalog", filecreatedate + ",\n" + filechangedate, "found:\n" + dmcfile)
        txt_catalog2_dates.set(filecreatedate + ", " + filechangedate)
        ckb_sqlite.set(TRUE)  # If we find the file locally, we assume SQLite

    select_notebook_tab("Compare")
    return


def browse_excl_paths(event=None):  # see https://pythonspot.com/en/tk-file-dialogs/
    excldir = filedialog.askdirectory(
        initialdir=txt_dbpath.get(), title="Select Folder to Exclude (= images in these folders are not tested)")
    if excldir != "":
        excludepaths = txt_excludepaths.get()
        excldir = "'" + excldir.replace('/', '\\') + "' " + excludepaths.rstrip()
        txt_excludepaths.set(excldir)
        txt_onlypaths.set("")
    select_notebook_tab("Compare")
    return


def browse_only_paths(event=None):  # see https://pythonspot.com/en/tk-file-dialogs/
    onlydir = filedialog.askdirectory(
        initialdir=txt_dbpath.get(), title="Select Folder to Include (= only images in these folders are tested)")
    if onlydir != "":
        onlypaths = txt_onlypaths.get()
        onlydir = "'" + onlydir.replace('/', '\\') + "' " + onlypaths.rstrip()
        txt_onlypaths.set(onlydir)
        txt_excludepaths.set("")
        select_notebook_tab("Compare")  # Make sure, Compare-Tab is selected and analysis_type = "Compare"
    return


def browse_for_excluded_tag_value_lists(event=None):  # see https://pythonspot.com/en/tk-file-dialogs/
    global args
    if int(rbtn_verbose_gui.get()) > 0: print('DamScanGUI_support.browse_for_excluded_tag_value_lists', flush=TRUE)
    sys.stdout.flush()
    file = filedialog.askopenfilename(
        initialdir=txt_pathconfigfiles.get(),
        title="Select File with List of Tag Values to be Excluded from Comparison",
        filetypes=(("Text files", "*.txt"), ("all files", "*.*")))
    if file != "":
        txt_exfile.set(file.replace('/', '\\'))
        txt_onlyfile.set("")
        args.onlyfile = ""
        select_notebook_tab("Scan")  # Make sure, Scan-Tab is selected and analysis_type = "Scan"


def browse_for_only_tag_value_lists(event=None):
    global args
    if int(rbtn_verbose_gui.get()) > 0: print('DamScanGUI_support.browse_for_only_tag_value_lists', flush=TRUE)
    file = filedialog.askopenfilename(  # see https://pythonspot.com/en/tk-file-dialogs/
        initialdir=txt_pathconfigfiles.get(),
        title="Select File with List of the ONLY Tag Values to be included for Comparison",
        filetypes=(("Text files", "*.txt"), ("all files", "*.*")))
    if file != "":
        txt_onlyfile.set(file.replace('/', '\\'))
        txt_exfile.set("")
        args.exfile = ""
        select_notebook_tab("Scan")  # Make sure, Scan-Tab is selected and analysis_type = "Scan"


def browse_paths_incl_excl_files():
    print('DamScanGUI_support.browse_paths_incl_excl_files')
    sys.stdout.flush()  # see https://pythonspot.com/en/tk-file-dialogs/
    onlydir = filedialog.askdirectory(
        initialdir=txt_pathconfigfiles.get(),
        title="Select Folder for Exclude-, Only- and Ack-List Files")
    if onlydir != "":
        onlypaths = txt_onlypaths.get()
        onlydir = "'" + onlydir.replace('/', '\\') + "' " + onlypaths.rstrip()
        txt_onlypaths.set(onlydir)


def browse_for_output_file():
    print('DamScanGUI_support.browse_paths_output_file')
    sys.stdout.flush()  # see https://pythonspot.com/en/tk-file-dialogs/
    outfile = filedialog.asksaveasfilename(initialdir=txt_dbpath.get(),
                                           title="Select a path and enter or select output file name",
                                           filetypes=(("Text files", "*.txt"), ("all files", "*.*")))
    if outfile != "":
        txt_outfilename.set(str(outfile.replace('/', '\\')))
    return

def clear_paths():
    txt_excludepaths.set("")
    txt_onlypaths.set("")


def edit_ack_file():
    print('DamScanGUI_support.edit_ack_file')
    sys.stdout.flush()
    res = subprocess.Popen("notepad.exe " + txt_ack_pairs.get())


def edit_excluded_file():
    print('DamScanGUI_support.edit_excluded_file')
    sys.stdout.flush()
    res = subprocess.Popen("notepad.exe " + txt_exfile.get())


def edit_only_file():
    print('DamScanGUI_support.edit_only_file')
    sys.stdout.flush()
    res = subprocess.Popen("notepad.exe " + txt_onlyfile.get())


def open_output_file_in_excel(event=None):  # Don't know, why I need to specify the path for excel. Works without path in command entry
    print('DamScanGUI_support.open_output_file_in_excel')
    sys.stdout.flush()
    res = subprocess.Popen(
        'C:\Program Files (x86)\Microsoft Office\Office12\excel.exe "' + txt_outfilename.get().strip('"') + '"')
    # See https://support.office.com/en-us/article/Command-line-switches-for-Microsoft-Office-products-079164CD-4EF5-4178-B235-441737DEB3A6#ID0EAABAAA=Excel


def open_output_file_in_notepad(event=None):
    print('DamScanGUI_support.open_output_file_in_notepad')
    sys.stdout.flush()
    res = subprocess.Popen('notepad.exe "' + txt_outfilename.get().strip('"') + '"')


def open_gui_config_in_notepad(event=None):  # <Control-w> = ctrl+w
    file = os.path.abspath(gui_conf_file_name)
    print('DamScanGUI_support.open_gui_config_in_notepad:', file)
    sys.stdout.flush()
    res = subprocess.Popen('notepad.exe "' + file + '"')


def open_ini_file_in_notepad(event=None):
    file = os.path.abspath(txt_newdamscanini.get().replace(".ini", "") + ".ini")  # <Control-W> = ctrl+shift+w
    print('DamScanGUI_support.open_ini_file_in_notepad:', file)
    sys.stdout.flush()
    res = subprocess.Popen('notepad.exe "' + file + '"')


def use_outfile_name_as_ack_file(event=None):
    print('DamScanGUI_support.use_outfile_name_as_ack_file')
    sys.stdout.flush()
    txt_ack_pairs.set(txt_outfilename.get().strip('"'))


def quit_button(event=None):
    print('DamScanGUI - Quit-button')
    sys.exit()


def run_compare_and_save_options(event=None):
    global analysis_type
    analysis_type = "Compare"
    newCmd, cmd_line_arguments = build_CMD_line()
    configfile = save_options_to_ini_files()
    w.Message1.configure(foreground="#000000")
    msg_error.set("Launching command: " + newCmd + cmd_line_arguments)
    if int(rbtn_verbose_gui.get()) > 0:
        print('DamScanGUI - Launching command:', newCmd + cmd_line_arguments)

    damprocess = subprocess.Popen(
        newCmd + cmd_line_arguments)  # stdout=PIPE, bufsize=1, universal_newlines=True)  # To run DamScan or DamCompare

    if int(rbtn_verbose_gui.get()) > 1:
        print('Function run_damcompare_no_save line:', getframeinfo(currentframe()).lineno, "damprocess:",
              damprocess)  # for debugging

    sys.stdout.flush()


def toggle_sqlite(event=None, field=None):
    global rows
    if int(rbtn_verbose_gui.get()) > 1:
        print('DamScanGUI_support.toggle_sqlite event:', event, field)
        sys.stdout.flush()

    server_attributes_changed = FALSE
    if event != None:
        if "FocusOut" in str(event) and "<ServerAttributes>" in field and (
                    args.port != txt_port.get() or args.server != txt_server.get() \
                or args.user != txt_user.get().strip() + "/" + txt_password.get().strip()):
            args.port   = txt_port.get()
            args.server = txt_server.get()
            args.user   = txt_user.get().strip() + "/" + txt_password.get().strip()
            server_attributes_changed = True
            ckb_sqlite.set(FALSE)

    if ckb_sqlite.get():
        args.sqlite = True                                      # -l, --sqlite Use Sqlite (= standalone)
        if os.path.exists(args.dbname):
            filecreatedate = \
                datetime.fromtimestamp(os.path.getctime(args.dbname)).strftime('\ncreated on %d.%m.%Y %H:%M:%S')
            filechangedate = \
                datetime.fromtimestamp(os.path.getmtime(args.dbname)).strftime('last changed on %d.%m.%Y %H:%M:%S')
            print("Daminion catalog found: " + args.dbname, filecreatedate + ",", filechangedate)
            txt_catalog_dates.set(filecreatedate + ", " + filechangedate)
            try:
                w.lbl_select_netcatalog_and_doubleclick.configure(state=DISABLED)
            except:
                pass
        else:
            print("Daminion catalog", args.dbname, "not found!")
            txt_catalog_dates.set("Daminion catalog not found!")
        if os.path.exists(args.dbname2):
            filecreatedate = \
                datetime.fromtimestamp(os.path.getctime(args.dbname2)).strftime('\ncreated on %d.%m.%Y %H:%M:%S')
            filechangedate = \
                datetime.fromtimestamp(os.path.getmtime(args.dbname2)).strftime('last changed on %d.%m.%Y %H:%M:%S')
            print("Daminion catalog found: " + args.dbname2, filecreatedate + ",", filechangedate)
            txt_catalog2_dates.set(filecreatedate + ", " + filechangedate)
            try:
                w.lbl_select_netcatalog2_and_doubleclick.configure(state=DISABLED)
            except:
                pass
        else:
            print("Second Daminion catalog", args.dbname2, "not found!")
            txt_catalog2_dates.set("Second Daminion catalog not found!")

    else:                                                       # instead Postgres (=server)
        if socket.gethostname() == txt_server.get():
            server = "localhost"
        else:
            server = txt_server.get()
        msg_error.set("")
        try:
            conn = psycopg2.connect(host=server, port=txt_port.get(),
                                    database="postgres", user=txt_user.get().strip(), password=txt_password.get())
        except Exception as error:                      # psycopg2.DatabaseError or psycopg2.OperationalError
            if not server_attributes_changed:           # if none of the server attributes were changed in the panel,
                if not args.sqlite: ckb_sqlite.set(FALSE) # we ignore errors accessing the server and do not change
                return                                  # sqlite indicator
            if len(error.args) > 0:
                if "0x0000274D" in error.args[0]:
                    error_right = str(error.args[0]).replace(
                        "could not connect to server: Connection refused (0x0000274D/10061)", "")
                    error_right = str(error_right.split("?", 1)[1]).replace("\n", "").lstrip().replace("\t", " ")
                    error_left = "Could not connect to server: Connection refused (0x0000274D/10061)"
                    print(error_left, "\n" + error_right)
                    txt_catalog_dates.set(str(error_left))
                    msg_error.set(error_right)
                else:
                    print("Could not connect to postgres database. Error:", error.args)
                    txt_catalog_dates.set("Could not connect to postgres database")
                    msg_error.set("Could not connect to postgres database")

            else:
                print("Could not connect to postgres database. Error:", error)
                txt_catalog_dates.set("Could not connect to postgres database")
                msg_error.set("Could not connect to postgres database")

            if args.sqlite: ckb_sqlite.set(TRUE)
            return

        args.sqlite = False
        cur = conn.cursor()  # Search for Daminion catalogs on server
        cur.execute("SELECT datname FROM pg_database WHERE datistemplate IS false AND datname NOT IN ('postgres')")
        rows = cur.fetchall()
        lst_netcatalogs.set(rows)
        txt_catalog_dates.set("Connected to: " + txt_server.get() + ":" + txt_port.get())
        txt_catalog2_dates.set("Connected to: " + txt_server.get() + ":" + txt_port.get())

        try:    w.lbl_select_netcatalog_and_doubleclick.configure(state=NORMAL)
        except: pass
        try:    w.lbl_select_netcatalog2_and_doubleclick.configure(state=NORMAL)
        except: pass


def toggle_display_and_output_file(event=None):
    if ckb_display_only.get():  ckb_display_only.set('1')
    else:                       ckb_display_only.set('0')


def toggle_fullpath(event=None):
    if ckb_fullpath.get() == "0":
        ckb_fullpath.set('1')
    else:
        ckb_fullpath.set('0')


def toggle_item_id(event=None):
    if ckb_itemid.get() == "0":
        ckb_itemid.set('1')
    else:
        ckb_itemid.set('0')


def run_analysis():  # & save options
    global analysis_type
    analysis_type = "Scan"
    newCmd, cmd_line_arguments = build_CMD_line()
    configfile = save_options_to_ini_files()
    w.Message1.configure(foreground="#000000")
    msg_error.set("Launching command: "+newCmd + cmd_line_arguments )

    if int(rbtn_verbose_gui.get()) > 0:
        print('DamScanGUI - Launching command:', newCmd + cmd_line_arguments)
    sys.stdout.flush()
    res = subprocess.Popen(newCmd + cmd_line_arguments)
    if int(rbtn_verbose_gui.get()) > 1:
        print('Function run_damcompare_no_save line:', getframeinfo(currentframe()).lineno, "variable res:", res)


def run_analysis_no_save(event=None):
    global analysis_type
    analysis_type = "Scan"
    newCmd, cmd_line_arguments = build_CMD_line()
    w.Message1.configure(foreground="#000000")
    msg_error.set("Launching command: "+ newCmd + cmd_line_arguments)

    if int(rbtn_verbose_gui.get()) > 1:
        print('DamScanGUI - Launching command :', newCmd + cmd_line_arguments)
    res = subprocess.Popen(newCmd + cmd_line_arguments)


def run_damcompare_no_save(event=None):
    global analysis_type
    analysis_type = "Compare"
    newCmd, cmd_line_arguments = build_CMD_line()
    w.Message1.configure(foreground="#000000")
    msg_error.set("Launching command: " + newCmd + cmd_line_arguments)
    print('DamScanGUI - Launching command :', newCmd + cmd_line_arguments)
    res = subprocess.Popen(newCmd + cmd_line_arguments)


def show_version_of_damscan_py():
    newCmd = 'python "' + txt_damscanpgm.get().rstrip(' ').replace('.py', '', -1) + '.py" --version'
    print(sys.argv[0], __doc__, '*** Version', __version__,
          "Using command to scan a single catalog:", os.getcwd() + "\\" + newCmd)
    res = subprocess.Popen(newCmd)
    sys.stdout.flush()
    rbtn_analysis_type.set('Scan')


def show_version_of_damcompare_pgm():
    newCmd = 'python "' + txt_damcompgm.get().rstrip(' ').replace('.py', '', -1) + '.py" --version'
    print(sys.argv[0], __doc__, '*** Version', __version__,
          "Using command to compare two catalogs:", os.getcwd() + "\\" + newCmd)
    res = subprocess.Popen(newCmd)
    sys.stdout.flush()
    rbtn_analysis_type.set('Compare')


def select_netcatalog(event=None):
    global w, rows
    print('DamScanGUI_support.select_netcatalog')
    sys.stdout.flush()

    if len(w.sltb_netcatalogs.curselection()) > 0:
        i = w.sltb_netcatalogs.curselection()[0]
    else:
        i = -1  # No recent file selected

    if int(rbtn_verbose_gui.get()) > 1: print('Func. select_netcatalog(event=None):',
                                              getframeinfo(currentframe()).lineno, event,
                                              w.sltb_netcatalogs.curselection(), "\n")
    if i >= 0:
        txt_dbname.set(str(rows[i]).strip("(),'"))
        print("Net Catalog:", txt_dbname.get(), "selected.")
        txt_dbpath.set("")  # Clear path, if netcatalog selected
    else:
        print("Nothing selected")


def select_netcatalog2(event=None):
    global rows
    print('DamScanGUI_support.select_netcatalog2')
    sys.stdout.flush()

    if len(w.sltb_netcatalogs2.curselection()) > 0:
        i = w.sltb_netcatalogs2.curselection()[0]
    else:
        i = -1  # No recent file selected

    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. select_netcatalog(event=None):', getframeinfo(currentframe()).lineno, event,
                                              w.sltb_netcatalogs.curselection(), "\n")
    if i >= 0:
        txt_dbname2.set(str(rows[i]).strip("(),'"))
        print("2. Net Catalog:", txt_dbname2.get(), "selected.")
        txt_dbpath2.set("")  # Clear path, if netcatalog selected
    else:
        print("Nothing selected")


def show_cmd_str_compare():
    global analysis_type
    analysis_type = 'Compare'
    newCmd, newCmdstring = build_CMD_line()  # Generated the new command line
    #    print("lstb_recent_ini_files :", lstb_recent_ini_files.get())      # For debugging
    w.Message1.configure(foreground="#000000")
    msg_error.set(newCmd + newCmdstring)
    print('DamScanGUI - Built command string to compare two catalogs:',
          newCmd + newCmdstring)  # Print the complete new command line


def show_cmd_str_scan():
    global analysis_type
    analysis_type = 'Scan'
    newCmd, newCmdstring = build_CMD_line()  # Generated the new command line
    #    print("lstb_recent_ini_files :", lstb_recent_ini_files.get())      # For debugging
    w.Message1.configure(foreground="#000000")
    msg_error.set(newCmd + newCmdstring)
    print('DamScanGUI - Built command string to scan a single catalog:',
          newCmd + newCmdstring)  # Print the complete new command line


def use_ini_name_as_outfile_name(test=None):
    sys.stdout.flush()
    txt_outfilename.set(txt_damscanini.get().strip('"').replace('.ini', '') + '.txt')


def use_dbname_as_ini(event=None):
    txt_damscanini.set(os.path.basename(txt_dbname.get().replace(".dmc", "")).replace(".ini", ""))
    txt_newdamscanini.set(os.path.basename(txt_dbname.get().replace(".dmc", "")).replace(".ini", ""))
    print('DamScanGUI_support.use_dbname_as_ini')
    sys.stdout.flush()


def build_CMD_line():
    global alltags
    global damscanpgm, damcompgm
    global args, analysis_type

    if analysis_type == None:
        analysis_type = rbtn_analysis_type.get()
    else:
        rbtn_analysis_type.set(analysis_type)
    if analysis_type == "Compare":
        newCmd = 'python "' + txt_damcompgm.get().rstrip(' ').replace('.py', '', -1) + '.py' + '"'
    else:
        newCmd = 'python "' + txt_damscanpgm.get().rstrip(' ').replace('.py', '', -1) + '.py' + '"'
    newArgString = ""

    if ckb_sqlite.get():
        newArgString += ' -l';
        args.sqlite = True
    elif txt_server.get() not in (""):
        args.server = txt_server.get()
        print(socket.gethostname())
        if socket.gethostname().strip().lower() == args.server.strip().lower():
            newArgString += " -s localhost"
        else:
            newArgString += " -s " + txt_server.get()
        if txt_port.get() not in (""):
            newArgString += " -p " + txt_port.get()
        if txt_user.get() not in (""):
            args.port = txt_port.get()
            newArgString += " -u " + txt_user.get() + "/" + txt_password.get()
            args.user = txt_user.get() + "/" + txt_password.get()

    if ckb_fullpath.get() == '1': newArgString += ' -f'; args.fullpath = True

    if rbtn_verbose.get() == '1':
        newArgString += ' -v';  args.verbose = 1
    elif rbtn_verbose.get() == '2':
        newArgString += ' -vv'; args.verbose = 2
    else:
        args.verbose = 0

    if ckb_itemid.get() == '1': newArgString += ' -i';  args.id = True

    args.dbname = args.dbname2 = ""
    if txt_dbpath.get() != "":
        args.dbname = str(str(txt_dbpath.get()).rstrip('\\') + '\\')
    args.dbname += txt_dbname.get().lstrip('\\')
    if txt_dbpath2.get() != "":
        args.dbname2 = str(str(txt_dbpath2.get()).rstrip('\\') + '\\')
    args.dbname2 += txt_dbname2.get().lstrip('\\')

    if args.sqlite == True:
        args.dbname = args.dbname.replace(".dmc", "").rstrip(' ') + ".dmc"
        args.dbname2 = args.dbname2.replace(".dmc", "").rstrip(' ') + ".dmc"

    if analysis_type == "Compare":
        newArgString += ' -c1 "' + args.dbname + '"';
        newArgString += ' -c2 "' + args.dbname2 + '"'
    else:
        if ckb_group.get() == '1':
            args.group = True
            newArgString += ' -g'
        newArgString += ' -c "' + args.dbname + '"'

    args.outfilename = str(txt_outfilename.get())
    if ckb_display_only.get():
        newArgString += ' -o "<stdout>"'
    elif txt_outfilename.get() != "<stdout>":
        newArgString += ' -o "' + args.outfilename.strip('"') + '"'

    pathconfigfiles = txt_pathconfigfiles.get().rstrip('\\') + '\\'
    if txt_exfile.get() > "0":
        args.exfile = str(str(txt_exfile.get()).lstrip('\\'))
        if not os.path.exists(args.exfile):
            msg_error.set("Error: Only-File (-x, --only) " + args.exfile + " does not exist - ignored!")
            print(msg_error.get())
            args.exfile = ""
    else:
        args.exfile = ""

    if txt_onlyfile.get() > "0":
        args.onlyfile = str(str(txt_onlyfile.get()).lstrip('\\'))
        if not os.path.exists(args.onlyfile):
            msg_error.set("Error: Only-File (-y, --only) " + args.onlyfile + " does not exist - ignored!")
            print(msg_error.get())
            args.onlyfile = ""
    else:
        args.onlyfile = ""

    if txt_ack_pairs.get() > "0":
        args.ack_pairs = str(str(txt_ack_pairs.get()).lstrip('\\'))
        if not os.path.exists(args.ack_pairs):
            msg_error.set(
                "Error: Acknowleged-File (-a, --acknowledged) " + args.ack_pairs + " does not exist - ignored!")
            print(msg_error.get())
            args.ack_pairs = ""
    else:
        args.ack_pairs = ""

    args.basename = txt_basename.get().strip("(',)")

    exclpaths = txt_excludepaths.get().strip().replace('""', "'")  # To avoid error ValueError: No closing quotation"
    if exclpaths > "0": args.exdir = shlex.split(exclpaths)

    onlypaths = txt_onlypaths.get().strip().replace('""', "'")  # To avoid error ValueError: No closing quotation"
    if onlypaths != "": args.onlydir = shlex.split(onlypaths)

    args.taglist = []
    if ckb_gps.get():        args.taglist.append("GPS")
    if ckb_title.get():      args.taglist.append("Title")
    if ckb_event.get():      args.taglist.append("Event")
    if ckb_place.get():      args.taglist.append("Place")
    if ckb_people.get():     args.taglist.append("People")
    if ckb_keywords.get():   args.taglist.append("Keywords")
    if ckb_comments.get():    args.taglist.append("Comments")
    if ckb_categories.get(): args.taglist.append("Categories")
    if ckb_collections.get(): args.taglist.append("Collections")
    if ckb_description.get(): args.taglist.append("Description")

    if analysis_type == "Scan":
        if args.exfile != None:
            if args.exfile != "":         newArgString += ' -x "' + args.exfile + '"'
        if args.onlyfile != None:
            if args.onlyfile != "":       newArgString += ' -y "' + args.onlyfile + '"'
        if args.ack_pairs != None:
            if txt_ack_pairs.get() != "": newArgString += ' -a "' + args.ack_pairs + '"'
        if txt_basename.get() != "":  # check base file name
            newArgString += " -b " + args.basename
            ckb_verify_basenames.set(TRUE)
        elif ckb_verify_basenames.get():  # check only file extensions
            args.basename = " "
            newArgString += " -b "

        newArgString += " -t "  # When no tags are checked, none will be used!
        if args.taglist != []:
            for i in range(len(args.taglist)):
                newArgString += args.taglist[i] + " "

    elif analysis_type == "Compare":  # Parameters only for DamCompare.py
        if txt_excludepaths.get() != "":
            newArgString += ' --excludepaths ' + str(args.exdir).strip("[]").replace("'", '"').replace(",", "").replace(
                "\\\\", "\\")
        if txt_onlypaths.get() != "":
            newArgString += ' --onlypaths ' + str(args.onlydir).strip("[]").replace("'", '"').replace(",", "").replace(
                "\\\\", "\\")

    damscanpgm = txt_damscanpgm.get().rstrip(' ').replace('.py', '', -1) + '.py'
    damcompgm = txt_damcompgm.get().rstrip(' ').replace('.py', '', -1) + '.py'

    return newCmd, newArgString


def select_ini_file(event=None):

    if len(w.Recent_ini_files1.curselection()) > 0:
        i = w.Recent_ini_files1.curselection()[0]
    else:
        i = -1  # No recent file selected

    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. select_ini_file(event=None):', getframeinfo(currentframe()).lineno, event,
                                              w.Recent_ini_files1.curselection(), "\n")
    if i >= 0:
        print('Options file "'+RecentDamScanINIfiles[i]+'.ini" selected.')
        txt_newdamscanini.set(RecentDamScanINIfiles[i])
        load_options_from_ini_file()
    else:
        print("Nothing selected")


def select_notebook_tab(analysis_type):
    global w
    # Selecting the appropriate tab of the notebook
    if analysis_type == 'Compare':
        w.tabs.select(w.tabs_t2)  # !!
    else:
        w.tabs.select(w.tabs_t1)
    rbtn_analysis_type.set(analysis_type)

    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. select_notebook_tab(analysis_type):', getframeinfo(currentframe()).lineno)  # for debugging


def toggle_analysis_type(event=None):
    global analysis_type

    analysis_type = rbtn_analysis_type.get()  # read status of radio buttons

    if event != None:  # Accelerator key pressed
        if event.keysym in ("t","2"):
            analysis_type = 'Compare'  # Alt-Ctrl-t pressed (= compare "Two")
        else:
            analysis_type = 'Scan'  # Alt-Ctrl-s pressed (= scan "Single")

    select_notebook_tab(analysis_type)  # Selecting the appropriate tab of the notebook

    if int(rbtn_verbose_gui.get()) > 1:
        print('Func. toggle_analysis_type():', getframeinfo(currentframe()).lineno)  # for debugging
    if int(rbtn_verbose_gui.get()) > 0:
        print('DamScanGUI_support.toggle_analysis_type:', event, analysis_type)
        sys.stdout.flush()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


if __name__ == '__main__':
    import DamScanGUI

    DamScanGUI.vp_start_gui()
